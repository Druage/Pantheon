/* COMPATIBILITY
   - HLSL compilers
   - Cg   compilers
*/

/*
   Hyllian's CRT Shader
   
   Copyright (C) 2011-2014 Hyllian/Jararaca - sergiogdb@gmail.com

   This program is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2
   of the License, or (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

   const static float  pi = 3.1415926535897932384626433832795;

const static float3x3 yuv = float3x3(0.299, 0.587, 0.114, -0.169, -0.331, 0.499, 0.499, -0.418, -0.0813);

#define SCANLINES  0.4


#define SINC2(X)\
      (X<(1E-5)) ?  1.0  :  sin(pi*X)*sin(pi*X)/(pi*X*pi*X);


        // Constants used with gamma correction.
        #define InputGamma 2.4
        #define OutputGamma 2.2

        #define GAMMA_IN(color)     pow(color, float4(InputGamma, InputGamma, InputGamma, InputGamma))
        #define GAMMA_OUT(color)    pow(color, float4(1.0 / OutputGamma, 1.0 / OutputGamma, 1.0 / OutputGamma, 1.0 / OutputGamma))


const static float4x4 invX = float4x4(-1.0/6.0,  0.5, -1.0/3.0, 0.0,
                                           0.5, -1.0,     -0.5, 1.0,
                                          -0.5,  0.5,      1.0, 0.0,
                                       1.0/6.0,  0.0, -1.0/6.0, 0.0);



struct input
{
    float2 video_size;
    float2 texture_size;
    float2 output_size;
        float  frame_count;
        float  frame_direction;
    float frame_rotation;
};


struct out_vertex {
    float2 texCoord;
    float4 t1;
    float4 t2;
    float4 t3;
    float4 t4;
    float4 t5;
    float4 t6;
    float4 t7;
    float2 t8;
};

/*    VERTEX_SHADER    */
out_vertex main_vertex
(
    float4 position    : POSITION,
   out float4 oPosition : POSITION,
    float2 tex1      : TEXCOORD0,

       uniform float4x4 modelViewProj,
    uniform input IN
)
{
    float2 ps = float2(1.0/IN.texture_size.x, 1.0/IN.texture_size.y);
    float dx = ps.x;
    float dy = ps.y;

float2 tex = tex1+float2(0.0000001, 0.0000001);
   oPosition = mul(modelViewProj, position);
/*
    out_vertex OUT = {
        tex,
        float4(tex,tex) + float4(   -dx,    -dy,    0.0,    -dy),
        float4(tex,tex) + float4(    dx,    -dy, 2.0*dx,    -dy),
        float4(tex,tex) + float4(   -dx,    0.0,     dx,    0.0),
        float4(tex,tex) + float4(2.0*dx,    0.0,    -dx,     dy),
        float4(tex,tex) + float4(   0.0,     dy,     dx,     dy),
        float4(tex,tex) + float4(2.0*dx,     dy,    -dx, 2.0*dy),
        float4(tex,tex) + float4(   0.0, 2.0*dy,     dx, 2.0*dy),
        tex             + float2(2.0*dx, 2.0*dy)
    };
*/
    out_vertex OUT = {
        tex,
        float4(tex,tex) + float4(-2.0*dx,   0.0,    -dx,    0.0),
        float4(tex,tex) + float4(    dx,    0.0,-2.0*dx,     dy),
        float4(tex,tex) + float4(   -dx,     dy,    0.0,     dy),
        float4(tex,tex) + float4(    dx,     dy,-2.0*dx, 2.0*dy),
        float4(tex,tex) + float4(   -dx, 2.0*dy,    0.0, 2.0*dy),
        float4(tex,tex) + float4(    dx, 2.0*dy,-2.0*dx, 3.0*dy),
        float4(tex,tex) + float4(   -dx, 3.0*dy,    0.0, 3.0*dy),
        tex             + float2(    dx, 3.0*dy)
    };

    return OUT;
}


float4 main_fragment(in out_vertex VAR, uniform sampler2D s_p : TEXUNIT0, uniform input IN) : COLOR
{

  float2 fp = frac(VAR.texCoord*IN.texture_size);

//  float2 fps = 0.0;

  float3 c00 = tex2D(s_p, VAR.t1.xy).xyz;
  float3 c01 = tex2D(s_p, VAR.t1.zw).xyz;
  float3 c02 = tex2D(s_p, VAR.texCoord).xyz;
  float3 c03 = tex2D(s_p, VAR.t2.xy).xyz;
  float3 c10 = tex2D(s_p, VAR.t2.zw).xyz;
  float3 c11 = tex2D(s_p, VAR.t3.xy).xyz;
  float3 c12 = tex2D(s_p, VAR.t3.zw).xyz;
  float3 c13 = tex2D(s_p, VAR.t4.xy).xyz;
  float3 c20 = tex2D(s_p, VAR.t4.zw).xyz;
  float3 c21 = tex2D(s_p, VAR.t5.xy).xyz;
  float3 c22 = tex2D(s_p, VAR.t5.zw).xyz;
  float3 c23 = tex2D(s_p, VAR.t6.xy).xyz;
  float3 c30 = tex2D(s_p, VAR.t6.zw).xyz;
  float3 c31 = tex2D(s_p, VAR.t7.xy).xyz;
  float3 c32 = tex2D(s_p, VAR.t7.zw).xyz;
  float3 c33 = tex2D(s_p, VAR.t8.xy).xyz;


  float4x4   red_matrix = float4x4(c00.x, c01.x, c02.x, c03.x,
                                   c10.x, c11.x, c12.x, c13.x,
                                   c20.x, c21.x, c22.x, c23.x,
                                   c30.x, c31.x, c32.x, c33.x);

  float4x4 green_matrix = float4x4(c00.y, c01.y, c02.y, c03.y,
                                   c10.y, c11.y, c12.y, c13.y,
                                   c20.y, c21.y, c22.y, c23.y,
                                   c30.y, c31.y, c32.y, c33.y);

  float4x4  blue_matrix = float4x4(c00.z, c01.z, c02.z, c03.z,
                                   c10.z, c11.z, c12.z, c13.z,
                                   c20.z, c21.z, c22.z, c23.z,
                                   c30.z, c31.z, c32.z, c33.z);


  float4x1 invX_Px = mul(invX, float4x1(fp.x*fp.x*fp.x, fp.x*fp.x, fp.x, 1.0));


  float red   = mul(  red_matrix, invX_Px);
  float green = mul(green_matrix, invX_Px);
  float blue  = mul( blue_matrix, invX_Px);

float2 pos = abs(fp - float2(0.5));

//float3 Y = mul( float3x3(c01, c02, c00), yuv[0] );
//Y = lerp(float3(0.1), float3(1.0), Y);
float2 Y;
Y.x = max(c01.r, max(c01.g, c01.b));
Y.y = max(c02.r, max(c02.g, c02.b));
Y = lerp(float2(0.1), float2(0.5), Y);
//Y.x = (c01.r + c01.g + c01.b)/3;
//Y.y = (c02.r + c02.g + c02.b)/3;
Y=pow(Y,0.5);
//float lum = (Y.x*(1.5-pos.x) + Y.y*(0.5+pos.x) + Y.z*(0.5-pos.x))/(2.5-pos.x);
float lum = lerp(Y.x,Y.y, 1.0-Y.x);

float d = clamp(pos.y/lum, 0.0, 1.0);

d = smoothstep(0.0, 1.0, 1.0-d);

float3 color = float3(red, green, blue);
//float3 color = c11.rgb;


float color_boost = 2.8;

color = clamp(color*d, 0.0, 1.0);

float mod_factor = VAR.texCoord.x * IN.output_size.x * IN.texture_size.x / IN.video_size.x;

float3 dotMaskWeights = lerp(
          float3(1.0, 0.7, 1.0),
          float3(0.7, 1.0, 0.7),
          floor(fmod(mod_factor, 2.0))
      );
                    


  
color = GAMMA_IN(color);
color.rgb *= dotMaskWeights;
color = color*color_boost;
color = GAMMA_OUT(color);

  return float4(color, 1.0);
}